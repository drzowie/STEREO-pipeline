## -*-perl-*-
use strict;

=head2 remove_f_corona - remove the F corona from a sequence of coronagraph/HI images

=for usage

 $ret = remove_f_corona( $images , $opt );

 # $images should be either a hash ref containing the images to be processed as a 3-D PDL in the "RAW_CUBE" field,
 # or a list ref of images.  If the RAW_CUBE field is used, the hash should also contain a RAW_HDRS list ref.

 # $opt is an options hash.

=for ref

C<remove_f_corona> is the first step in both the hi-1 and hi-2 pipelines, and therefore it includes the process
of loading the data into memory.  (It would not be unreasonable to break this first step out in a future version).

If you supply a list ref of images or image names, then the images are regularized and a data processing hash is 
created.  The images undergo some preprocessing and filtering to reject images that appear to not be part of a 
regular sequence.  In particular:

=over 3

=item size filtering

If you hand in a list of FITS file names, then the images must exactly
match the specified image size, or they are skipped.

As a special case, if you hand in pre-loaded images and set the C<bin>
option flag, then 2048x2048 images are binned down to 1024x1024.

=item rotation filtering

The C<CROTA> field of the header is checked for each image.  If any of
them deviate by more than a few degrees (determined by the
C<REJECT_BY_CROTA> option) from the batch average, then those frames
are rejected.  This filters out roll maneuvers.

=item sum filtering

Each image is summed.  Images whose sum is too different from the
median for the whole data set (the amount is set by the
C<REJECT_BY_SUM> option) are rejected.  This gets rid of miscellaneous
pointing and exposure time irregularities, and does a good job of
finding the occasional mislabeled image in the STEREO data set
(e.g. there are some binned COR images in the HI-1 data stream).

=back

The images are also normalized in two important ways:

=item badval cleaning

Bad values in the image are cleaned up.  Bad regions are dilated all around
(amount set by the BAD_DIL_PIX option) and then filled in with median
values of their periphery.

=item exposure fluctuation correction

The images are normalized to a constant sum.  This is a big deal because 
the exposure times given in the headers appear to be accurate only to 
within a few tenths of a percent, which is not sufficient to stabilize
the background.  This is done by a call to C<remove_fluctuations()>.

=back

After the initial ingestion and cleaning, the F corona subtraction is
straightforward: the images are sorted and the specified percentile
value is used as an F corona model and subtracted.  The F corona model
can be smoothed if desired.  

The percentile value calculation approximates a more complete noise
analysis of the data, which would be required to generate a "real" F
coronal model.  The problem is that a given pixel value contains
(signal + noise); sampling the minimum value of a long time series for
a given pixel as is commonly done in coronagraph data, samples both a
near-minimum value of the signal and also a near-minimum value of the
noise.  This systematically underestimates the F corona.  Selecting a
slightly-above-zero percentile offsets this slightly.

The skewed sampling of the noise distribution can be seen as fine
spatial structure in the resulting F corona model, which tracks the
motion of stars through the field; and also as a small residual signal
in the parts of the image where the F corona is brightest.  The effect
is described by DeForest, Howard & Tappin (2011).  These artifacts
can be smoothed out with the C<sm> option, which smooths the resulting
F corona model via median filtering.

Options are:

=over 3


=item pct - percentile to use for the f corona

The percentile value to treat as the f corona.  The default 5 is appropriate for
HI-2A.

=item sm - smooth the f corona model by median filtering

This is a 2-array ref describing how much median smoothing should be
applied to the background.  The default [7,30] is appropriate for
HI-2A.

=item bin - don't use

C<bin> is left in for historical reasons but is neither needed nor
helpful in normal use.

=item neg - specify negative-value handling

Controls how negative values should be handled on input.  Valid values
are C<bad>, C<max>, C<zero>, or C<mask>.  The default C<bad> should normally
be used.

=item MARK_BAD - flag to cause certain points to be marked bad

=item MASK_THRESH - threshold value for badness

Points with values higher than MASK_THRESH are marked BAD if the MARK_BAD flag is set.

=item MASK_RADIUS - circular masking

This is useful for HI-2 data.  Points outside the specified radius are marked bad. Set
this to 0 to disable it.

=item IMG_SIZE - require an image dimension

Images whose height or width is different from IMG_SIZE are rejected.

=item 

FIXME

=back



=cut

use PDL::NiceSlice;
use PDL::Transform;
use PDL::Bad;
sub  remove_f_corona {
     local($PDL::BIGPDL) = 1;
     my $VERSION = "2.0 5-May-2013";
     my $i;

     # Read parameters
     my $in = shift;
     my $opt = shift;
     $opt = {} unless defined($opt);

     # Set default values for options
     $opt->{'neg'}    = "bad"  unless( exists( $opt->{'neg'}  )  ); # how to handle negative values
     $opt->{'pct'}    = 5      unless( exists( $opt->{'pct'}  )  ); # percentile for background
     $opt->{'sm'}     = [7,30] unless( exists( $opt->{'sm'}   )  ); # smoothing of background
     $opt->{'bin'}    = 0      unless( exists( $opt->{'bin'}  )  ); # whether to deal with multiply binned full-frame images
     $opt->{'MASK_THRESH'} = 500 unless( exists($opt->{'MASK_THRESH'}) );
     $opt->{'MASK_RADIUS'} = 500 unless(exists($opt->{'MASK_RADIUS'}));
     $opt->{'MARK_BAD'} = 1 unless(exists($opt->{'MARK_BAD'}));
     $opt->{'IMG_SIZE'} = 1024 unless(exists($opt->{'IMG_SIZE'}));
     $opt->{'REJECT_BY_SUM'} = 0.03 unless(exists($opt->{'REJECT_BY_SUM'})); 
     $opt->{'REJECT_BY_CROTA'} = 2 unless(exists($opt->{'REJECT_BY_CROTA'}));
     $opt->{'CLEAN_BAD'} = 1 unless(exists($opt->{'CLEAN_BAD'}));
     $opt->{'BAD_DIL_PIX'} = 1 unless(exists($opt->{'BAD_DIL_PIX'}));
     $opt->{'BAD_DIL_FR'} = 0 unless(exists($opt->{'BAD_DIL_FR'}));

     print cards($opt);
     # Make sure we have a data cube in usable form
     my ($ims, $hdrs);
     if(ref $in eq 'HASH') {
	 if(defined($in->{'RAW_CUBE'}) && defined($in->{'RAW_HDRS'}) ) {
	     $ims = $in->{'RAW_CUBE'};
	 } else {
	     die "remove_f_corona: input hash needs both RAW_CUBE and RAW_HDRS fields\n";
	 }
     } elsif( ref $in eq 'ARRAY') {

	 # Handle case where an array of FITS files is entered
	 if( ref $in->[0] eq 'PDL' ) {
	     # prefrobnicate 2048x2048 images down to 1024x1024
	     if($opt->{'bin'}) {
		 my $ndc = ndcoords(1024,1024);
		 
		 for $i(0..$#$in) {
		     if( $in->[$i]->dim(0) == 2048 &&
			 $in->[$i]->dim(1) == 2048
			 ) {
			 # Explicit binning
			 
			 # Sum over quads of pixels (2x2 binning).  The first 
			 # (commented out) case doesnt' work, apparently due to a problem
			 # with the binning in the STEREO pipeline.
			 my $im2;
			 
			 $im2 = (   $in->[$i]->(0:-2:2,0:-2:2) 
				    + $in->[$i]->(1:-1:2,0:-2:2)
				    + $in->[$i]->(0:-2:2,1:-1:2)
				    + $in->[$i]->(1:-1:2,1:-1:2)
			     ) / 4;
			 print "i=$i; 2048x2048 -> 1024x1024 (/4)\n";
			 
			 # Patch up header in the binned image
			 $im2->sethdr($in->[$i]->hdr_copy);
			 
			 # CRPIX is off-by-one.  The -0.5 moves the origin to the lower-left corner of the 
			 # lower-left pixel, and the +0.5 moves it back to the center of the lower-left pixel.
			 $im2->hdr->{CRPIX1} = ($in->[$i]->hdr->{CRPIX1}-0.5)/2 + 0.5; 
			 $im2->hdr->{CRPIX2} = ($in->[$i]->hdr->{CRPIX2}-0.5)/2  +0.5;
			 $im2->hdr->{CDELT1} *= 2;
			 $im2->hdr->{CDELT2} *= 2;
			 
			 $in->[$i] = $im2;
			 
		     }
		 }
	     } # end of 'bin' special case
	 } else {
	     # Handle case where an array of FITS file names is entered
	     my @cube;
	     for my $fname(@$in) {
		 my $im = float rfits($fname,{hdrcpy=>1});
		 if($im->dim(0) != $opt->{IMG_SIZE} || $im->dim(1) != $opt->{IMG_SIZE}) {
		     print "File $fname isn't $opt->{IMG_SIZE}x$opt->{IMG_SIZE}.  Skipping.\n";
		 } else {
		     push @cube, $im;
		 }
	     }
	     $in = \@cube;
	 }
	 $ims = pdl(float, @{$in});
	 $in = {
	     RAW_CUBE => $ims,
	     RAW_HDRS => [ map { $_->hdr } @$in ],
	 };
     } else {
	 die "remove_f_corona: need a hash ref or an array ref as first argument\n";
     }

#     $ims = $ims->setbadif(!isfinite($ims));

     ##############################
     # Handle negative values - BAD or maxval
     if($opt->{'neg'} eq 'bad') {
	 $ims = $ims->setbadif($ims<0);
     } elsif($opt->{'neg'} eq 'max') {
	 $ims->where($ims<0) .= $ims->max;
     } elsif($opt->{'neg'} eq 'zero') {
	 $ims->where($ims<0) .= 0;
     } elsif($opt->{'neg'} eq 'mask') {
	 $ims->where($ims<0) .= $ims->max + 10000;
     } else {
	 die("remove_f_corona: neg option must be 'bad' or 'max'\n");
    }

     ##############################
     # Clean bad values if asked for and needed
     if($opt->{'CLEAN_BAD'}){
	 my $badloc = whichND($ims->isbad);
	 if($badloc->nelem){
	     print "Found ".$badloc->nelem." bad locations.  Dilating with radius=$opt->{BAD_DIL_PIX} pixels, $opt->{BAD_DIL_FR} frames";
	     for my $i (-$opt->{BAD_DIL_PIX}..$opt->{BAD_DIL_PIX}) {
		 for my $j(-$opt->{BAD_DIL_PIX}..$opt->{BAD_DIL_PIX}) {
		     next if($i*$i + $j*$j  >  $opt->{BAD_DIL_PIX} * $opt->{BAD_DIL_PIX});
		     for my $fr(-$opt->{BAD_DIL_FR} .. $opt->{BAD_DIL_FR}) {
			 p "($i,$j,$fr)\t";
			 $ims->indexND($badloc + pdl($i,$j,$fr), 'e') .= $ims->badvalue;
			 print ".";
		     }
		 }
	     }
	     print "\nNow there are ".($ims->isbad->sum)." bad values.  Cleaning up...";
	     clean_baddies($ims, 2);
	 }
     }

     ##############################
     # Deal with rejecting rotated files...
     if($opt->{'REJECT_BY_CROTA'}) {
	 my $crota = pdl( map { $_->{CROTA}} @{$in->{RAW_HDRS}} );
	 my $cm = $crota->median;
	 my $mask = ( ( $crota <= $cm + $opt->{'REJECT_BY_CROTA'} ) & 
		      ( $crota >= $cm - $opt->{'REJECT_BY_CROTA'} ) );
	 if($mask->sum < $mask->nelem) {
	     print "Rejecting frames for CROTA: ".((!$mask)->which)."\n";
	     my $goodies = $mask->which;
	     $ims = $ims->(:,:,$goodies)->sever;
	     $in->{RAW_CUBE} = $ims;
	     $in->{RAW_HDRS} = [ @{$in->{RAW_HDRS}}[$goodies->list] ];
	 }
     }

     ##############################
     # Deal with rejecting bad files...
     if($opt->{'REJECT_BY_SUM'}) {
	 my $sums = $ims->sumover->sumover;
	 my $median = $sums->median;
	 my $medlo = $median / (1 + $opt->{'REJECT_BY_SUM'});
	 my $medhi = $median * (1 + $opt->{'REJECT_BY_SUM'});
	 
	 my @baddies = (($sums > $medhi) | ($sums < $medlo))->which->list;
	 
	 if(@baddies) {
	     print "Remove_f_corona: Rejecting frames ".join(",",@baddies)."\n";
	     print "median sum is $median, medhi is $medhi, medlo is $medlo\n";
	     my $goodies = (($sums <= $medhi) & ($sums >= $medlo))->which;
	     $ims = $ims->(:,:,$goodies)->sever;
	     $in->{RAW_CUBE} = $ims;
	     $in->{RAW_HDRS} = [ @{$in->{RAW_HDRS}}[$goodies->list] ];
	 }
     }

     if($opt->{'REMOVE_FLUCTUATIONS'}) {
	 remove_fluctuations($ims,$opt);
     }
     
     ##############################
     # Sort the cube by value to find a percentile image
     my $sorted = $ims->mv(-1,0)->qsort->sever;

     ##############################
     # Find the index of the closest value to the desired percentile
     my $sn = $sorted->dim(0) * ($opt->{'pct'}/100) + 0.5;
     # Take the percentile and smooth as necessary

     my $bk;;
     if(ref($opt->{'sm'}) eq 'ARRAY') {
	 my $smsiz= $opt->{'sm'}->[0];
	 my $smpct = $opt->{'sm'}->[1];
	 my $smdex = ($smsiz * $smsiz)  * ($smpct /100) + 0.5;
	 $bk = $sorted
	     ->(($sn))
	     ->range(  ndcoords($smsiz,$smsiz)->clump(1,2)-3,  [$sorted->(($sn))->dims],  'e')
	     ->qsort
	     ->(($smdex));
     } else {
	 $bk = $sorted->(($sn));
     }

     my $out = $in;
#     $out->{SORTED} = $sorted;
#     $out->{FBK} = $bk;
     $out->{BKSUB_CUBE} = $ims - $bk;

     $out->{FCORONA} = $bk;

     print "Making badval masks...\n";
     $out->{MASK_CUBE} = ones(byte, $out->{BKSUB_CUBE}->dims);

     my $rvm = 1;

     if($opt->{MASK_RADIUS}) {
	 $rvm = ( rvals($out->{BKSUB_CUBE}->(:,:,(0))) < $opt->{MASK_RADIUS} )->byte;
     }
	 
     if($opt->{MARK_BAD}) {
	 print "marking bad points...\n";
	 for $i(0..$out->{BKSUB_CUBE}->dim(2)-1) {
	     my $m = 1;
	     if($opt->{MASK_THRESH}) {
		 $m = ($out->{BKSUB_CUBE}->(:,:,($i))->med2d(ones(3,3)) <= $opt->{MASK_THRESH})->convolveND(ones(3,3)/9);
	     }
	     $out->{MASK_CUBE}->(:,:,($i)) .= ($rvm * $m) > 0.999 ;
	     print "$i ";
	 }
	 print "\n";
	 
	 if($opt->{'neg'} eq 'mask') {
	     $out->{BKSUB_CUBE}->where($ims>10000) .= 10000;
	 }
     }

     unless(exists($out->{log})) {
	 $out->{log} = [];
     }

     push(@{$out->{log}},"  remove_f_corona v$VERSION");

     print "returning from remove_f_corona...\n";     
     return $out;
}
