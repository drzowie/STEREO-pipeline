=head2 merge_batches - merge a dataset from the hi-2 pipeline

=for usage 

 merge_batches( \@files, \%opt );

=for ref

You feed in a collection of file names and an optional options hash, and the files are merged into a single set of FITS files in the destination directory ("merged" by default or set by the option "MERGED_DIR").

=cut

use strict;
use Date::Format;

sub merge_batches {
    my $files = shift;
    my $opt = shift;
    my $VERSION = "2.1 28-May-2013";
    
    $opt = {} unless defined($opt);
    $opt->{MERGED_DIR} = "L2" unless(defined $opt->{MERGED_DIR});
    $opt->{PROCESSES} = 8 unless(defined $opt->{PROCESSES});
    $opt->{MARGIN} = 40 unless(defined $opt->{MARGIN});    
    $opt->{START} = 0 unless(defined $opt->{START});
    $opt->{REGEXP} = 'clean\-(.*)\-\-BATCH.*' unless(defined $opt->{REGEXP});
    $opt->{PTYPE} = '' unless(defined($opt->{PTYPE}));  # processing type -- 'S' or 'M'
    my $ptype = $opt->{PTYPE};

    if($opt->{MERGED_DIR}  and  !(-d $opt->{MERGED_DIR})){
	`mkdir $opt->{MERGED_DIR}`;
    }

    my %filenames = ();
    
    print "Sorting ".(0+@$files)." files based on name...\n";

    for $file(@$files) {
	my $f2 = $file;
	$f2 =~ s:.*/::;
	unless($f2 =~ m/$opt->{REGEXP}/) {
	    print "File $f2 doesn't match -- skipping\n";
	    next;
	} 
	my $fdate = $1;
	print "fdate=$fdate\n";
	unless(exists($filenames{$fdate})){
	    $filenames{$fdate} = [];
	}
	
	push(@{$filenames{$fdate}}, $file);
    }

    # Now the filenames have been sorted.  Begin accumulating.

    my %pids = ();

    my @k = sort keys %filenames;
    print "start is $opt->{START}; k is $#k\n";
    for my $ii($opt->{START}..$#k) {

	my $f = $k[$ii];

	next unless(@{$filenames{$f}} > 1);

    	while( (0 + keys %pids) >= $opt->{PROCESSES} ) {
	  my $pid = wait();
	  if($pid<0) {
	      %pids = ();
	  }
	  delete $pids{$pid};
	}

	if((0 + keys %pids) < $opt->{PROCESSES}) {

	    my $fh = rfits($filenames{$f}->[0],{DATA=>0});
	    my $out_fname;
	    if($fh->{FILENAME}) {
		$out_fname = $fh->{FILENAME};
		$out_fname =~ s/_[1b](....\.fts)$/_2$ptype$1/;  # update L1 to L2
	    } else {
		$out_fname = "merged-$f.fits";
	    }
	    my $mfname = sprintf("%s/%s",($opt->{MERGED_DIR} || "."),$out_fname) ;

	    my $pid = fork();

	    if($pid<0) {
		die "fork failed\n";
	    } 

	    if($pid) {
		# parent
		$pids{$pid}=$mfname;
		print "Spawned task for $mfname\n";
	    } else {
		# daughter
		print "Evalling...\n";
		eval {
		    my $ksiz = $opt->{MARGIN}*2 + 1;
		    my $k = (1 + cos( (rvals($ksiz,$ksiz)*3.141592653/$opt->{MARGIN})->clip(0,)));
		    $k /= $k->sum;
		    
		    print "$f: ".(0+@{$filenames{$f}})." files...";

		    my @cube = mrfits(@{$filenames{$f}});
		    my $cube = pdl(@cube)->mv(-1,0)->sever;
		    my $hdr = $cube[0]->gethdr;
		    undef @cube;
		    
		    my $baddies = !($cube->isfinite->short);  # actual baddies
		    $cube->where($baddies) .= 0;  	      # Mask out the bad values in the original cube so they don't cause trouble later

		    my $badmask = $baddies->copy;             # becomes a dilated mask

		    # dilate the badmask
		    for my $i(0..$badmask->dim(0)-1) {
			print ",";
			$badmask->(($i)) .= $badmask->(($i))->convolveND(ones($opt->{MARGIN}+2,$opt->{MARGIN}+2),{method=>'direct'});
		    }

		    # Generate the feathering screen.  Start with 1 for good, 0 for bad.
		    my $weight = (!$baddies)->float;

		    # Convolve the weight for smooth transition
		    for my $i(0..$weight->dim(0)-1) {
		    	print ".";
			$weight->(($i)) .= $weight->(($i))->convolveND($k,{method=>'direct'});
		    }

		    my $avg = ($cube*$weight)->sumover / $weight->sumover;
		    
		    ##############################
		    # Add new header fields
		    $hdr->{COMMENT} .= "Background model removed; some stars and artifacts may remain\n";
		    $hdr->{HISTORY} .= "Merged batches with merge_batch $VERSION\n";
		    $hdr->{HISTORY} .= "Removed background model (SwRI pipeline; PDL) CED\n   (Some artifacts may remain)";
		    $hdr->{ORIGIN}  = 'SwRI (contact: deforest@boulder.swri.edu) / Post-processed at SwRI';

		    $hdr->{DATE} = time2str("%Y-%m-%dT%H:%M:%S",time,'Z');
		    my $ptype = $opt->{PTYPE};
		    $hdr->{FILENAME} = $out_fname;

		    $avg->sethdr($hdr);
		    print "writing $mfname\n";
		    wfits( $avg, $mfname);
		};
		if($@){
			print STDERR "daughter: $@\n";
		}
		exit 0;
	    }
	} else {
	    print "Hmmm...\n";
	}
    }
    while(keys %pids) {
	my $p = wait();
	return unless(defined($p) and $p>0);
	delete $pids{$p};
    }
}    
